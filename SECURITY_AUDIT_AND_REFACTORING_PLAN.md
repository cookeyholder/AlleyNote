# AlleyNote 專案安全審查與重構計畫 (最終版)

本文件旨在記錄 AlleyNote 專案的資訊安全審查和程式碼重構建議。審查重點在於常見的安全漏洞、冗餘功能及架構設計，並提供具體的改善步驟。

## 總結

此專案在關鍵安全領域（如密碼雜湊、SQL 注入防護）有著良好的基礎。開發者顯然具備安全意識。然而，在一些實作細節、軟體架構和相依性管理上，仍有值得改善的空間，以進一步提升系統的安全性與可維護性。本最終版報告納入了對業務邏輯、資訊洩漏和高併發場景的深度分析。

---

## 第一部分：資訊安全漏洞

### 1. 相依套件潛在漏洞 (Dependency Vulnerabilities)

- **發現**: `composer.json` 檔案定義了專案的相依套件，但沒有機制確保這些套件一直保持在最新的安全版本。
- **原因與威脅**: 第三方函式庫可能存在已知的安全漏洞（CVEs）。若不定期更新，攻擊者可利用這些已知漏洞來入侵系統，這是供應鏈攻擊的一種形式。
- **改善建議**:
    1.  **整合自動化掃描**: 在 CI/CD 流程中（例如 `.github/workflows/ci.yml`）加入 `composer audit` 指令。此指令會檢查 `composer.lock` 檔案，比對已安裝套件版本與已知的安全漏洞資料庫。
    2.  **定期更新**: 建立定期（例如每週或每月）更新相依性套件的開發流程。可以考慮使用像 Dependabot 這樣的工具來自動發送更新的 Pull Request。

### 2. 弱密碼檢查機制不足

- **發現**: `PasswordSecurityService.php` 中用於檢查弱密碼的 `COMMON_PASSWORDS` 列表是寫死在程式碼中的，且僅包含約 20 個常見密碼。
- **原因與威脅**: 寫死的密碼列表規模太小，無法防禦字典攻擊或基於常見洩露密碼的攻擊。使用者仍可能設定出雖然符合複雜度要求、但實際上非常不安全的密碼。
- **改善建議**:
    1.  **整合外部密碼服務**: 棄用寫死的列表，改為整合 [Have I Been Pwned (HIBP) 的 Pwned Passwords API](https://haveibeenpwned.com/Passwords)。
    2.  **實作步驟**:
        - 在使用者註冊或變更密碼時，將使用者輸入的密碼（的 SHA-1 雜湊值）傳送給 HIBP API。
        - API 會回傳該密碼是否出現在已知的資料外洩事件中。
        - 如果密碼已被洩露，應拒絕使用並提示使用者選擇一個更獨特的密碼。

### 3. XSS 防護情境單一

- **發現**: `XssProtectionService.php` 使用 `htmlspecialchars` 來防禦 XSS，這是一個好的基礎防護。
- **原因與威脅**: `htmlspecialchars` 只能有效處理在 HTML 內文中輸出的資料。若未來系統需要在 JavaScript 變數、HTML 屬性或 URL 中輸出使用者內容，此函式可能無效甚至被繞過。此外，它無法滿足讓使用者發布部分安全 HTML（如文章編輯器）的需求。
- **改善建議**:
    1.  **引入 HTML 過濾器**: 如果有讓使用者輸入豐富內容（如粗體、清單）的需求，應引入一個強大的 HTML 過濾函式庫，例如 [HTML Purifier](http://htmlpurifier.org/)。
    2.  **設定白名單**: 設定 HTML Purifier，只允許安全的 HTML 標籤和屬性（例如 `<b>`, `<i>`, `<ul>`, `<li>`, `<p>`），並過濾掉所有危險的內容（如 `<script>`, `onerror`）。
    3.  **維持現狀**: 如果確定系統永遠不會允許使用者輸入任何 HTML，則目前的 `htmlspecialchars` 機制是足夠的，但應在註解中明確標示其限制。

### 4. 潛在的二階 SQL 注入風險

- **發現**: 在 `PostRepository.php` 的 `update` 和 `paginate` 方法中，SQL 查詢的欄位名稱是直接從外部傳入的陣列 `key` 拼接而成。
- **原因與威脅**: 雖然所有傳入的 *數值* 都經過參數化處理，非常安全，但 *欄位名稱* 並未經過驗證。若攻擊者能控制傳入陣列的 `key`（例如，透過修改前端發送的 JSON 物件），就可能注入惡意的 SQL 語法，繞過查詢邏輯。
- **改善建議**:
    1.  **建立欄位白名單**: 在 `update` 和 `paginate` 方法中，建立一個允許被更新或查詢的欄位白名單陣列。
    2.  **驗證欄位**: 在迴圈中拼接 SQL 之前，檢查傳入的 `$key` 是否存在於白名單中。如果不存在，應直接忽略或拋出異常。

### 5. 權限控制缺失（不安全的直接物件參考 - IDOR）

- **發現**: `AttachmentController.php` 中的 `upload` 和 `delete` 方法，在執行操作前，並未驗證當前使用者是否有權限操作指定的文章（`post_id`）或附件（`uuid`）。
- **原因與威脅**: 這是典型的「不安全的直接物件參考（IDOR）」漏洞，屬於存取控制失效（Broken Access Control）的一種，是 OWASP Top 10 的頭號風險。此漏洞允許任何已登入的使用者，只要能猜測或獲取到目標的 ID，就能對任意文章上傳附件，或刪除任意附件，導致資料完整性被嚴重破壞。
- **改善建議**:
    1.  **在 Service 層實作權限檢查**: `AttachmentService` 是執行權限檢查的理想位置。
    2.  **取得當前使用者**: 應從請求（Request）或 Session 中獲取當前登入使用者的 User ID。
    3.  **驗證資源所有權**: 檢查資源的擁有者是否為當前使用者，或當前使用者是否具備管理員權限。

### 6. 業務邏輯中的競爭條件 (Race Condition)

- **發現**: `PostService` 中多個方法（如 `deletePost`, `setPinned`）採用了「先檢查、後執行」的模式，且這兩步並非原子操作。
- **原因與威脅**: 在高併發場景下，攻擊者可發送兩個幾乎同時的請求。第一個請求通過了狀態檢查（例如，檢查文章是否為「草稿」），但在它執行刪除操作之前，第二個請求將文章狀態改為「已發布」。此時，第一個請求將成功刪除一篇「已發布」的文章，從而繞過了「已發布文章不能刪除」的業務規則。
- **改善建議**:
    1.  **使用資料庫鎖**: 這是根治此類問題的方法。應將「檢查-執行」的邏輯序列放入一個資料庫交易中。
    2.  **悲觀鎖**: 在交易開始時，使用 `SELECT ... FOR UPDATE` 語句查詢並鎖定目標資料列，防止任何其他行程修改它，直到交易結束。
    3.  **樂觀鎖**: 或在資料表中增加一個 `version` 欄位。每次更新時，都驗證 `version` 是否與讀取時相同（`UPDATE ... WHERE id = ? AND version = ?`），若不同則表示資料已被修改，操作應失敗或重試。

### 7. 透過驗證錯誤的資訊洩漏

- **發現**: `ErrorHandlerService` 在處理 `ValidationException` 時，會將完整的錯誤訊息直接回傳給使用者。
- **原因與威脅**: 雖然這能提供良好的使用者體驗，但若錯誤訊息設計不當，可能洩漏系統內部狀態，導致使用者枚舉（User Enumeration）漏洞。例如，若註冊失敗時回傳「使用者 'admin' 已存在」，攻擊者即可確認 'admin' 帳號的有效性。
- **改善建議**:
    1.  **通用化錯誤訊息**: 所有由使用者輸入觸發的驗證失敗，對外顯示的訊息應保持通用，例如「提供的欄位無效」或「請求無法處理」。
    2.  **日誌記錄細節**: 將具體的失敗原因（例如「使用者名稱重複」）只記錄在伺服器端的安全日誌中，供內部除錯使用。

---

## 第二部分：重構與架構改善

### 1. 重複的環境設定檔

- **發現**: 專案根目錄下同時存在 `.env.example` 和 `env.example` 兩個檔案。
- **改善建議**: 統一使用 `.env.example` 作為業界標準，並刪除 `env.example` 以避免混淆。

### 2. 職責劃分不清 (Validation in Repository)

- **發現**: `PostRepository.php` 中包含了大量的業務邏輯驗證。
- **改善建議**: 將驗證邏輯完整遷移到 `PostValidator` 中，讓 Repository 只專注於資料庫互動，Service 層負責呼叫 Validator 並處理業務流程。

### 3. 重複的程式碼邏輯 (Tag Validation)

- **發現**: 在 `PostRepository.php` 中，驗證標籤是否存在的邏輯重複出現多次。
- **改善建議**: 建立一個私有的輔助方法來集中此邏輯，讓其他方法呼叫它，以符合 DRY 原則。

### 4. Session 設定邏輯重複

- **發現**: `SecurityHeaderService` 與 `SessionSecurityService` 中，都包含了對 Session cookie 的設定邏輯。
- **改善建議**: 移除 `SecurityHeaderService` 中的相關方法，將所有 Session 設定統一由 `SessionSecurityService` 管理。

### 5. 間接的巨量賦值 (Mass Assignment) 風險

- **發現**: `PostService` 的多個方法直接接收一個關聯陣列 (`array $data`) 作為參數。
- **改善建議**: 建立嚴格定義的資料傳輸物件 (DTO) 來取代 `array $data`。例如，建立 `CreatePostDTO`，其僅包含 `title`, `content` 等明確的屬性。這能讓方法簽章更清晰，並在編譯時期就防止非預期欄位被傳入，徹底杜絕巨量賦值風險。

### 6. 冗餘的查詢方法

- **發現**: 在 `PostService` 中，`getPost(int $id)` 和 `findById(int $id)` 兩個方法的功能完全重複。
- **改善建議**: 移除其中一個，統一命名慣例。

---

## 第三部分：深度安全強化建議 (Hardening)

本部分旨在提出超越常規標準的深度安全強化建議，以應對更進階的威脅，並提升系統的整體健全度。

### 1. Session 管理機制的強化

- **IP 綁定的副作用**: 目前將 Session 與 IP 強綁定的策略可能因使用者網路變化而影響體驗。**建議**：可考慮將「IP 變更」作為一個高風險訊號，觸發二次驗證，而不是直接中斷 Session。
- **缺少 User-Agent 綁定**: **建議**: 在 Session 建立時儲存 User-Agent 字串並在後續請求中比對，這是一個偵測 Session 劫持的、副作用較低的有效指標。
- **`cookie_secure` 旗標寫死**: **建議**: 此設定應與環境變數掛鉤，只在生產環境 (`APP_ENV=production`) 中啟用。

### 2. CSRF 防護機制的強化

- **未使用恆定時間比較**: 權杖驗證使用 `!==` 比較，理論上存在被「時序攻擊」的風險。**建議**: 將權杖比較改為 `hash_equals()`。
- **多頁籤可用性問題**: 整個 Session 共用一個權杖會導致多頁籤操作時權杖失效。**建議**: 採用「權杖池」模式，在 Session 中維護一個權杖陣列，每個權杖只使用一次。

### 3. HTTP 安全標頭 (CSP) 的強化

- **`unsafe-inline` 的危險**: 預設的 CSP 策略允許 `'unsafe-inline'`，會讓防護效果大打折扣。**建議**: 必須移除 `'unsafe-inline'`，並改用 `nonce`（隨機數）策略來處理內聯腳本。
- **缺少監控與報告**: CSP 策略缺少 `report-to` 指令，導致無法監控其阻擋效果與潛在攻擊。**建議**: 新增 `report-to` 指令，將違規報告發送到一個監控服務。

### 4. 速率限制架構的強化

- **反向代理的 IP 偵測問題**: 系統直接使用 `REMOTE_ADDR`，在反向代理後方會失效。**建議**: 實作一個可信任代理的機制，只有當請求來自可信任的 IP 時，才採用 `X-Forwarded-For` 標頭。
- **缺乏精細化限制**: 所有端點共用一個限制。**建議**: 應為不同敏感度的操作（如登入、發文）設定不同的限制規則。
- **未針對使用者限制**: 未對已登入的使用者 ID 進行限制。**建議**: 對於已驗證的請求，速率限制的鍵值應改為使用者 ID。

### 5. 日誌與監控的強化

- **日誌中的 IP 位址不準確**: 所有日誌直接使用 `REMOTE_ADDR`，在反向代理後方會記錄到錯誤的 IP。**建議**: 建立一個全域共用的、能感知代理的 IP 解析服務，並在整個應用程式中一致地使用它。
- **日誌過濾的繞過風險**: `sanitizeLogData` 使用黑名單過濾。**建議**: 對於記錄請求資料這類高度敏感的操作，應改為「白名單模式」，預設不記錄任何請求參數，只明確記錄已知安全的欄位。
- **日誌檔案的權限過寬**: 程式碼只設定了日誌目錄的權限。**建議**: 在建立 Monolog 的 `StreamHandler` 時，應明確地將檔案權限參數設為 `0640`，確保日誌檔案本身不會被同群組的其他使用者讀取。
